//
// Created by user on 23/03/2020.
//

#ifndef VECTOR_H
#define VECTOR_H

#include <memory>
#include <exception>
#include <iostream>


namespace my_push_back
{


enum SIZE
{
	DEFAULT_SIZE = 10
};

/*I've tried to implement a strict guarantee of security relative the exception
 * in my class vector*/

template<class T,
	class Alloc = std::allocator<T>>
class vector
{
public:
	using traits = std::allocator_traits<Alloc>;
	using ptr = typename traits::pointer;
	/*default constructor allocate just a raw memory for default
	 * numbers of objects*/
	vector();
	~vector();
	vector(const vector &t) = delete;
	vector &operator=(const vector &t) = delete;
	T &operator[](const std::size_t i) noexcept;
	const T &operator[](const std::size_t i) const noexcept;
	std::size_t size() const noexcept;
	std::size_t capasity() const noexcept;

	/*I have written the implementation in the manner of re-throwing an exception
	 * in case when it was generated by some situations in push_back method
	 * But as you can see in definition of it I have followed the most important rule about safety
	 * regarding exception they are :
	 * [1] : Not to produce any leak of memory
	 * [2] : Not to change any data to yucky condition [dangling pointers, for example] */
	void push_back(const T &t);              // the strict guarantee relative generating exception in this method

	/*In the case when the user would like to insert the element from this->arr_ (example using operator[])
	 * then we consider such a situation as he has shoot himself in the foot*/
	void push_back(T &&t);                  // analogous about safety in case of exception
private :
	T *arr_ = nullptr;
	std::size_t cap_ = DEFAULT_SIZE;
	std::size_t sz_ = 0;
	Alloc alloc;
};

template<class T, class Alloc>
std::size_t vector<T, Alloc>::size() const noexcept
{ return sz_; }

template<class T, class Alloc>
std::size_t vector<T, Alloc>::capasity() const noexcept
{ return cap_; }

template<class T, class Alloc>
vector<T, Alloc>::vector()
{
	arr_ = traits::allocate(alloc, cap_);
}

template<class T, class Alloc>
vector<T, Alloc>::~vector()
{
	for (std::size_t i = 0; i < sz_; ++i) {
		traits::destroy(alloc, arr_ + i);
	}
	traits::deallocate(alloc, arr_, cap_);
}

template<class T, class Alloc>
void vector<T, Alloc>::push_back(const T &t)
{
	if (sz_ < cap_) {
		traits::construct(alloc, (arr_ + sz_), t); //copy constructor
		++sz_;
		return;
	}
	std::size_t i = 0;
	ptr new_arr = traits::allocate(alloc, cap_ * 2); //consider an error in allocating memory --> std::bad_alloc();
	std::size_t save_cap_ = cap_;
	cap_ <<= 1;
	try {
		for (; i < sz_; ++i) {
			traits::construct(alloc, new_arr + i, arr_[i]);  //copy constructor
		}
		traits::construct(alloc, (new_arr + sz_), t);
		++sz_;
		//the code below shouldn't throw any exception --- because of calling destructors and delete method for arr_
		for (std::size_t i = 0; i < (sz_ - 1); ++i) {
			traits::destroy(alloc, arr_ + i);
		}
		traits::deallocate(alloc, arr_, save_cap_);

		arr_ = new_arr;
	}
	catch (...) {
		for (std::size_t j = 0; j < i; ++j) {
			traits::destroy(alloc, new_arr + j);
		}
		traits::deallocate(alloc, new_arr, cap_);
		cap_ = save_cap_;
		throw;
	}

}

/*I don't know yet how to understand if an object of T type has a
 * noexcept move constructor exactly ( But soon I'll be notified of such
 * nice features in C++). In that case I'd easily move just all the
 * element from the old version of field arr_ into the new memory
 * but In this case I should prevent throwing an exception in case when we forced to use copy constructor*/
template<class T, class Alloc>
void vector<T, Alloc>::push_back(T &&t)
{
	if (sz_ < cap_) {
		traits::construct(alloc, (arr_ + sz_), std::move(t));
		++sz_;
		return;
	}
	ptr new_arr_ = traits::allocate(alloc, cap_ * 2);
	std::size_t save_cap = cap_;
	cap_ <<= 1;

	traits::construct(alloc, (new_arr_ + sz_), std::move(t));
	++sz_;

	for (std::size_t i = 0; i < (sz_ - 1); ++i) {
		traits::construct(alloc, new_arr_ + i, std::move(arr_[i]));
	}
	traits::deallocate(alloc, arr_, save_cap);
	arr_ = new_arr_;
}

template<class T, class Alloc>
T &vector<T, Alloc>::operator[](const std::size_t i) noexcept
{
	//assume this operator[] can do something else beside returning just a ref
	return const_cast<T &>(static_cast<const vector<T, Alloc> &>(*this)[i]);
}
template<class T, class Alloc>
const T &vector<T, Alloc>::operator[](const std::size_t i) const noexcept
{
	return arr_[i];
}

}
#endif //VECTOR_H
