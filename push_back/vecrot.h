//
// Created by user on 23/03/2020.
//

#ifndef VECROT_H
#define VECROT_H

#include <memory>
#include <exception>
#include <iostream>

enum SIZE
{
	_DEFAULT_SIZE_ = 10
};

/*I've tried to implement a strict guarantee of security relative the exception
 * in my class vecrot*/

template<class T,
	class Alloc = std::allocator<T>>
class vecrot
{
public:
	using traits = std::allocator_traits<Alloc>;
	using ptr = typename traits::pointer;
	/*default constructor allocate just a raw memory for default
	 * numbers of objects*/
	vecrot();
	~vecrot();
	vecrot(const vecrot &t) = delete;
	vecrot &operator=(const vecrot &t) = delete;
	T &operator[](const std::size_t i) noexcept;
	const T &operator[](const std::size_t i) const noexcept;
	std::size_t size() const noexcept;
	std::size_t capasity() const noexcept;

	/*I have written the implementation in the manner of re-throwing an exception
	 * in case when it was generated by some situations in push_back method
	 * But as you can see in definition of it I have followed the most important rule about safety
	 * regarding exception they are :
	 * [1] : Not to produce any leak of memory
	 * [2] : Not to change any data to yucky condition [dangling pointers, for example] */
	void push_back(const T &t);              // the strict guarantee relative generating exception in this method

	/*Notes : implementation of this method should be very smart due to the case
	 * when the user wants to put an object from the previous array (e.g. some returned from operator[]) */
	void push_back(T &&t);                  // analogous
private :
	T *arr_ = nullptr;
	std::size_t cap_ = _DEFAULT_SIZE_;
	std::size_t sz_ = 0;
	Alloc alloc;
	bool check_copy_construction(ptr arr, const T &t);
};

template<class T, class Alloc>
std::size_t vecrot<T, Alloc>::size() const noexcept
{ return sz_; }

template<class T, class Alloc>
std::size_t vecrot<T, Alloc>::capasity() const noexcept
{ return cap_; }

template<class T, class Alloc>
vecrot<T, Alloc>::vecrot()
{
	arr_ = traits::allocate(alloc, cap_);
}

template<class T, class Alloc>
vecrot<T, Alloc>::~vecrot()
{
	for (std::size_t i = 0; i < sz_; ++i) {
		traits::destroy(alloc, arr_ + i);
	}
	traits::deallocate(alloc, arr_, cap_);
}

template<class T, class Alloc>
void vecrot<T, Alloc>::push_back(const T &t)
{
	if (sz_ < cap_) {
		traits::construct(alloc, (arr_ + sz_), t); //copy constructor
		++sz_;
		return;
	}
	std::size_t i = 0;
	ptr new_arr = traits::allocate(alloc, cap_ * 2); //consider an error in allocating memory --> std::bad_alloc();
	std::size_t save_cap_ = cap_;
	cap_ <<= 1;
	try {
		for (; i < sz_; ++i) {
			traits::construct(alloc, new_arr + i, arr_[i]);  //copy constructor
		}
		traits::construct(alloc, (new_arr + sz_), t);
		++sz_;
		//the code below shouldn't throw any exception --- because of calling destructors and delete method for arr_
		for (std::size_t i = 0; i < (sz_ - 1); ++i) {
			traits::destroy(alloc, arr_ + i);
		}
		traits::deallocate(alloc, arr_, save_cap_);

		arr_ = new_arr;
	}
	catch (...) {
		for (std::size_t j = 0; j < i; ++j) {
			traits::destroy(alloc, new_arr + j);
		}
		traits::deallocate(alloc, new_arr, cap_);
		cap_ = save_cap_;
		throw;
	}

}

/*I don't know yet how to understand if an object of T type has a
 * noexcept move constructor exactly ( But soon I'll be notified of such
 * nice features in C++). In that case I'd easily move just all the
 * element from the old version of field arr_ into the new memory
 * but In this case I should prevent throwing an exception in case when we forced to use copy constructor*/
template<class T, class Alloc>
void vecrot<T, Alloc>::push_back(T &&t)
{
	if (sz_ < cap_) {
		/*This check is for prevention move the element from the exact this object
		 * It can appear if an user want to perform push_back to the element which is situated in this->arr_
		 * array of this vecrot (e.g. this can take place when use push_back for the element std::move(ht[ip]) */
		if (check_copy_construction(arr_, t))
			return;
		traits::construct(alloc, (arr_ + sz_), std::move(t));
		++sz_;
		return;
	}
	ptr new_arr_ = traits::allocate(alloc, cap_ * 2);
	std::size_t save_cap = cap_;
	cap_ <<= 1;
	//analogous check as in the branch above
	if (!check_copy_construction(new_arr_, t)) {
		traits::construct(alloc, (new_arr_ + sz_), std::move(t));
		++sz_;
	}
	for (std::size_t i = 0; i < (sz_ - 1); ++i) {
		traits::construct(alloc, new_arr_ + i, std::move(arr_[i]));
	}
	traits::deallocate(alloc, arr_, save_cap);
	arr_ = new_arr_;
}

template<class T, class Alloc>
bool vecrot<T, Alloc>::check_copy_construction(ptr arr, const T &t)
{
	for (std::size_t i = 0; i < sz_; ++i) {
		if (&arr_[i] == &t) {
			traits::construct(alloc, (arr + sz_), t);    //simple copy constructor
			++sz_;
			return true;
		}
	}
	return false;
}

template<class T, class Alloc>
T &vecrot<T, Alloc>::operator[](const std::size_t i) noexcept
{
	//assume this operator[] can do something else beside returning just a ref
	return const_cast<T &>(static_cast<const vecrot<T, Alloc> &>(*this)[i]);
}
template<class T, class Alloc>
const T &vecrot<T, Alloc>::operator[](const std::size_t i) const noexcept
{
	return arr_[i];
}
#endif //VECROT_H
