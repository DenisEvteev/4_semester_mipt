        -:    0:Source:vecrot.h
        -:    0:Graph:tests/testVecrot.gcno
        -:    0:Data:tests/testVecrot.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// Created by user on 23/03/2020.
        -:    3://
        -:    4:
        -:    5:#ifndef VECROT_H
        -:    6:#define VECROT_H
        -:    7:
        -:    8:#include <memory>
        -:    9:#include <exception>
        -:   10:#include <iostream>
        -:   11:
        -:   12:enum SIZE{
        -:   13:	_DEFAULT_SIZE_ = 10
        -:   14:};
        -:   15:
        -:   16:/*I've tried to implement a strict guarantee of security relative the exception
        -:   17: * in my class vecrot*/
        -:   18:
        -:   19:template <class T,
        -:   20:	class Alloc = std::allocator<T>>
        -:   21:class vecrot
        -:   22:{
        -:   23:public:
        -:   24:	using traits = std::allocator_traits<Alloc>;
        -:   25:	using ptr = typename traits::pointer;
        -:   26:	/*default constructor allocate just a raw memory for default
        -:   27:	 * numbers of objects*/
        -:   28:	vecrot();
        -:   29:	~vecrot();
        -:   30:	vecrot(const vecrot& t) = delete;
        -:   31:	vecrot&operator=(const vecrot& t) = delete;
        -:   32:	T& operator[](const std::size_t i) noexcept;
        -:   33:	const T& operator[](const std::size_t i)const noexcept;
        -:   34:	std::size_t size()const noexcept;
        -:   35:	std::size_t capasity()const noexcept;
        -:   36:
        -:   37:	/*I have written the implementation in the manner of re-throwing an exception
        -:   38:	 * in case when it was generated by some situations in push_back method
        -:   39:	 * But as you can see in definition of it I have followed the most important rule about safety
        -:   40:	 * regarding exception they are :
        -:   41:	 * [1] : Not to produce any leak of memory
        -:   42:	 * [2] : Not to change any data to yucky condition [dangling pointers, for example] */
        -:   43:	void push_back(const T& t);              // the strict guarantee relative generating exception in this method
        -:   44:
        -:   45:	/*Notes : implementation of this method should be very smart due to the case
        -:   46:	 * when the user wants to put an object from the previous array (e.g. some returned from operator[]) */
        -:   47:	void push_back(T&& t);                  // analogous
        -:   48:private :
        -:   49:	T*          arr_    = nullptr;
        -:   50:	std::size_t cap_ 	= _DEFAULT_SIZE_;
        -:   51:	std::size_t sz_  	= 0;
        -:   52:	Alloc       alloc;
        -:   53:	bool check_copy_construction(ptr arr, const T& t);
        -:   54:};
        -:   55:
        -:   56:template <class T, class Alloc>
      226:   57:std::size_t vecrot<T, Alloc>::size()const noexcept{ return sz_; }
        -:   58:
        -:   59:template <class T, class Alloc>
        7:   60:std::size_t vecrot<T, Alloc>::capasity()const noexcept{ return cap_; }
        -:   61:
        -:   62:template <class T, class Alloc>
        4:   63:vecrot<T, Alloc>::vecrot()
        -:   64:{
        4:   65:	arr_ = traits::allocate(alloc, cap_);
        4:   66:}
        -:   67:
        -:   68:template <class T, class Alloc>
        4:   69:vecrot<T, Alloc>::~vecrot()
        -:   70:{
      239:   71:	for(std::size_t i = 0; i < sz_; ++i){
      235:   72:		traits::destroy(alloc, arr_ + i);
        -:   73:	}
        4:   74:	traits::deallocate(alloc, arr_, cap_);
        4:   75:}
        -:   76:
        -:   77:template<class T, class Alloc>
      113:   78:void vecrot<T, Alloc>::push_back(const T& t)
        -:   79:{
      113:   80:	if(sz_< cap_)
        -:   81:	{
      107:   82:		traits::construct(alloc, (arr_ + sz_), t); //copy constructor
      107:   83:		++sz_;
      107:   84:		return;
        -:   85:	}
        6:   86:	std::size_t i = 0;
        6:   87:	ptr new_arr = traits::allocate(alloc, cap_ * 2); //consider an error in allocating memory --> std::bad_alloc();
        6:   88:	std::size_t save_cap_ = cap_;
        6:   89:	cap_ <<= 1;
        -:   90:	try{
      346:   91:		for( ; i < sz_; ++i){
      170:   92:			traits::construct(alloc, new_arr + i, arr_[i]);  //copy constructor
        -:   93:		}
        6:   94:		traits::construct(alloc, (new_arr + sz_), t);
        5:   95:		++sz_;
        -:   96:		//the code below shouldn't throw any exception --- because of calling destructors and delete method for arr_
      165:   97:		for(std::size_t i = 0; i < (sz_ - 1); ++i){
      160:   98:			traits::destroy(alloc, arr_ + i);
        -:   99:		}
        5:  100:		traits::deallocate(alloc, arr_, save_cap_);
        -:  101:
        5:  102:		arr_ = new_arr;
        2:  103:	}catch(...){
       11:  104:		for(std::size_t j = 0; j < i; ++j){
       10:  105:			traits::destroy(alloc, new_arr + j);
        -:  106:		}
        1:  107:		traits::deallocate(alloc, new_arr, cap_);
        1:  108:		cap_ = save_cap_;
        1:  109:		throw;
        -:  110:	}
        -:  111:
        -:  112:}
        -:  113:
        -:  114:
        -:  115:/*I don't know yet how to understand if an object of T type has a
        -:  116: * noexcept move constructor exactly ( But soon I'll be notified of such
        -:  117: * nice features in C++). In that case I'd easily move just all the
        -:  118: * element from the old version of field arr_ into the new memory
        -:  119: * but In this case I should prevent throwing an exception in case when we forced to use copy constructor*/
        -:  120:template<class T, class Alloc>
      124:  121:void vecrot<T, Alloc>::push_back(T&& t){
      124:  122:	if(sz_ < cap_){
        -:  123:		/*This check is for prevention move the element from the exact this object
        -:  124:		 * It can appear if an user want to perform push_back to the element which is situated in this->arr_
        -:  125:		 * array of this vecrot (e.g. this can take place when use push_back for the element std::move(ht[ip]) */
      118:  126:		if(check_copy_construction(arr_, t))
        2:  127:			return;
      115:  128:		traits::construct(alloc, (arr_ + sz_), std::move(t));
      115:  129:		++sz_;
      115:  130:		return;
        -:  131:	}
        6:  132:	ptr new_arr_ = traits::allocate(alloc, cap_ * 2);
        6:  133:	std::size_t save_cap = cap_;
        6:  134:	cap_ <<= 1;
        -:  135:	//analogous check as in the branch above
        6:  136:	if(!check_copy_construction(new_arr_, t)){
        6:  137:		traits::construct(alloc, (new_arr_ + sz_), std::move(t));
        6:  138:		++sz_;
        -:  139:	}
      186:  140:	for(std::size_t i = 0; i < (sz_ - 1); ++i){
      180:  141:		traits::construct(alloc, new_arr_ + i, std::move(arr_[i]));
        -:  142:	}
        6:  143:	traits::deallocate(alloc, arr_, save_cap);
        6:  144:	arr_ = new_arr_;
        -:  145:}
        -:  146:
        -:  147:template <class T, class Alloc>
      124:  148:bool vecrot<T, Alloc>::check_copy_construction(ptr arr, const T& t){
     5334:  149:	for(std::size_t i = 0; i < sz_; ++i){
     5213:  150:		if(&arr_[i] == &t){
        3:  151:			traits::construct(alloc, (arr + sz_), t);    //simple copy constructor
        2:  152:			++sz_;
        2:  153:			return true;
        -:  154:		}
        -:  155:	}
      121:  156:	return false;
        -:  157:}
        -:  158:
        -:  159:template<class T, class Alloc>
      124:  160:T& vecrot<T, Alloc>::operator[](const std::size_t i) noexcept
        -:  161:{
        -:  162:	//assume this operator[] can do something else beside returning just a ref
      124:  163:	return const_cast<T&>(static_cast<const vecrot<T, Alloc>&>(*this)[i]);
        -:  164:}
        -:  165:template<class T, class Alloc>
      124:  166:const T& vecrot<T, Alloc>::operator[](const std::size_t i)const noexcept
        -:  167:{
      124:  168:	return arr_[i];
        -:  169:}
        -:  170:#endif //VECROT_H
