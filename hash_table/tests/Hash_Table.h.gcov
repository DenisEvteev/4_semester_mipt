        -:    0:Source:Hash_Table.h
        -:    0:Graph:Hash_Table.gcno
        -:    0:Data:Hash_Table.gcda
        -:    0:Runs:5
        -:    0:Programs:5
        -:    1://
        -:    2:// Created by user on 28/02/2020.
        -:    3://
        -:    4:
        -:    5:#ifndef HASH_TABLE_HASH_TABLE_H
        -:    6:#define HASH_TABLE_HASH_TABLE_H
        -:    7:
        -:    8:#include <new>
        -:    9:#include <iostream>
        -:   10:#include <cstring>
        -:   11:#include <cassert>
        -:   12:#include <iterator>
        -:   13:#include <functional>
        -:   14:#include <stack>
        -:   15:#include <map>
        -:   16:#include <fstream>
        -:   17:
        -:   18://#define C_PLUS_PLUS_IS_ALLOWED 3802
        -:   19://#define DEBUG_PRINT_HASH_TABLE 2020
        -:   20:
        -:   21:enum SIZE
        -:   22:{
        -:   23:	_HASH_TABLE_SIZE = 128
        -:   24:};
        -:   25:
        -:   26:template<class T>
        -:   27:class Hash_Table;
        -:   28:template<class T>
        -:   29:std::ofstream &operator<<(std::ofstream &out, const Hash_Table<T> &ht);
        -:   30:
        -:   31:template<class Key>
        -:   32:class Hash_Table
        -:   33:{
        -:   34:public :
        -:   35:	/*This multimap will contain the distribution of buckets and its respective values
        -:   36:	 * in sort order. Via this container I will be able to show the result print it to file or STDOUT_FILENO*/
        -:   37:	using info = std::multimap<std::size_t, Key>;
        -:   38:
        -:   39:	explicit Hash_Table(std::size_t size = _HASH_TABLE_SIZE);
        -:   40:	~Hash_Table();
        -:   41:	Hash_Table(const Hash_Table &hash_table);
        -:   42:	Hash_Table &operator=(const Hash_Table &ht);
        -:   43:	const std::size_t &size() const noexcept;
        -:   44:	static void *operator new(std::size_t size);
        -:   45:	static void operator delete(void *ptr) noexcept;
        -:   46:	void showDistribution(info &map) const;
        -:   47:	friend std::ofstream &operator<<<>(std::ofstream &out, const Hash_Table<Key> &ht);
        -:   48:private :
        -:   49:
        -:   50:	class Node
        -:   51:	{
        -:   52:		Node *left_ = nullptr;
        -:   53:		Node *right_ = nullptr;
        -:   54:		Key value;
        -:   55:	public:
        -:   56:		explicit Node(const Key &t);
        -:   57:		Node() = delete;
        -:   58:		const Node *get_right() const noexcept;
        -:   59:		void set_right(Node *right) noexcept;
        -:   60:		void set_left(Node *left) noexcept;
        -:   61:		const Node *get_left() const noexcept;
        -:   62:		Node *get_left() noexcept;
        -:   63:		Node *get_right() noexcept;
        -:   64:		const Key &get_value() const noexcept;
        -:   65:		Node* ptr_to_last_in_bucket(const Node* ptr_from)const noexcept;
        -:   66:	};
        -:   67:
        -:   68:	Node *deep_copy_bucket(const Node *bucket_ptr) const;
        -:   69:	void destroy_bucket(Node *bucket_ptr) const noexcept;
        -:   70:
        -:   71:	class NewHandlerHolder
        -:   72:	{
        -:   73:	public:
    72752:   74:		explicit NewHandlerHolder(std::new_handler ptr)
    72752:   75:			: currentHandler(ptr)
    72752:   76:		{}
        -:   77:		NewHandlerHolder(const NewHandlerHolder &holder) = delete;
        -:   78:		NewHandlerHolder &operator=(const NewHandlerHolder &holder) = delete;
    72752:   79:		~NewHandlerHolder()
    72752:   80:		{ std::set_new_handler(currentHandler); }
        -:   81:	private :
        -:   82:		std::new_handler currentHandler = nullptr;
        -:   83:	};
        -:   84:
        -:   85:
        -:   86:public:
        -:   87:	class Iterator
        -:   88:	{
        -:   89:		using value_type = Key;
        -:   90:		using pointer = Key *;
        -:   91:		using reference = Key &;
        -:   92:		using difference_type = std::size_t;
        -:   93:		using iterator_category = std::bidirectional_iterator_tag;
        -:   94:
        -:   95:	public :
        -:   96:		Iterator() = default;
        -:   97:		Iterator(std::size_t n, std::size_t max, Node *ptr, Node **hash_p);
        -:   98:		Iterator(const Iterator &it) = default;
        -:   99:		Iterator &operator=(const Iterator &it) = default;
        -:  100:
        -:  101:		Key &operator*(); // this operator will cause runtime_error in case when we are about to dereference nullptr
        -:  102:		const Key &operator*() const;
        -:  103:
        -:  104:		Node *operator->();
        -:  105:		const Node *operator->() const;
        -:  106:
        -:  107:		Iterator &operator++() noexcept;
        -:  108:		const Iterator operator++(int);
        -:  109:
        -:  110:		Iterator &operator--() noexcept;
        -:  111:		const Iterator operator--(int);
        -:  112:
        -:  113:		bool operator==(const Iterator &it) const noexcept;
        -:  114:		bool operator!=(const Iterator &it) const noexcept;
        -:  115:
        -:  116:
        -:  117:	private :
        -:  118:		std::size_t nbucket_ = 0; // this variable will maintain the current number of bucket
        -:  119:		std::size_t max_buckets = _HASH_TABLE_SIZE;
        -:  120:		Node *ptr_ =
        -:  121:			nullptr;          // this is the main part of this iterator due to I'm going to go through the left and right pointer
        -:  122:		Node **hash_t = nullptr;     // this pointer will maintain the main array of hash_table
        -:  123:	};
        -:  124:
        -:  125:	Iterator findEl(const Key &key, std::size_t &bucket);
        -:  126:	Iterator begin();
        -:  127:
        -:  128:	Iterator end();
        -:  129:
        -:  130:	bool insert(const Key &key);
        -:  131:	bool erase(const Key &key);
        -:  132:	/*These operators will throw an exception of type std::out_of_range in case when
        -:  133:	 * i is out of bound array hash_t*/
        -:  134:	Node *operator[](const std::size_t i);
        -:  135:	const Node *operator[](const std::size_t i) const;
        -:  136:
        -:  137:private :
        -:  138:
        -:  139:	Node **hash_t = nullptr; // It's a pointer to the array of pointers (aka hash_table structure)
        -:  140:	std::size_t n_buckets = _HASH_TABLE_SIZE;
        -:  141:	static int number_allocations;
        -:  142:	static Node **alloc_ptr;       // It's a pointer which I'm going to use for hash_t in the case of dynamic alloc
        -:  143:	static void mem_handler();
        -:  144:	std::size_t hash_func(const Key &key);
        -:  145:
        -:  146:};
        -:  147:
        -:  148:#endif //HASH_TABLE_HASH_TABLE_H
