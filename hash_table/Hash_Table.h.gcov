        -:    0:Source:Hash_Table.h
        -:    0:Graph:Hash_Table.gcno
        -:    0:Data:Hash_Table.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// Created by user on 28/02/2020.
        -:    3://
        -:    4:
        -:    5:#ifndef HASH_TABLE_HASH_TABLE_H
        -:    6:#define HASH_TABLE_HASH_TABLE_H
        -:    7:
        -:    8:#include <new>
        -:    9:#include <iostream>
        -:   10:#include <stack>
        -:   11:#include <map>
        -:   12:#include <fstream>
        -:   13:
        -:   14://#define C_PLUS_PLUS_IS_ALLOWED 3802
        -:   15://#define DEBUG_PRINT_HASH_TABLE 2020
        -:   16:
        -:   17:enum SIZE
        -:   18:{
        -:   19:	_HASH_TABLE_SIZE = 128,
        -:   20:	_CONDITION_TO_GENERATE_EXCEPTION_ = 3802
        -:   21:};
        -:   22:
        -:   23:
        -:   24:/*I implement a struct which will throw an exception at the special case
        -:   25: * So I will be able to check the state of objects Hash_Table when deep_copy_bucket can generate
        -:   26: * an exception in more complicated case */
        -:   27:struct Yucky {
        -:   28:	int a_;
        -:   29:	explicit Yucky(int a) : a_(a) {};
    16000:   30:	Yucky(Yucky&& rhs) noexcept : a_(rhs.a_) { rhs.a_ = 0;}
    15056:   31:	Yucky(const Yucky& rhs) : a_(rhs.a_){
        -:   32:		//generate an exception at the special case
    15056:   33:		if(a_ == _CONDITION_TO_GENERATE_EXCEPTION_)
        2:   34:			throw std::invalid_argument("condition to generate exception in copy ctor");
    15054:   35:	};
    #####:   36:	bool operator==(const Yucky& rhs)const noexcept{
    #####:   37:		return (a_ == rhs.a_);
        -:   38:	}
        -:   39:};
        -:   40:
        -:   41:template<class T>
        -:   42:class Hash_Table;
        -:   43:template<class T>
        -:   44:std::ofstream &operator<<(std::ofstream &out, const Hash_Table<T> &ht);
        -:   45:
        -:   46:template <>
        -:   47:struct std::hash<Yucky>{
    12000:   48:	std::size_t operator()(const Yucky& rhs)const noexcept{
        -:   49:		std::hash<int> hash_f;
    12000:   50:		return hash_f(rhs.a_);
        -:   51:	}
        -:   52:};
        -:   53:
        -:   54:template<class Key>
        -:   55:class Hash_Table
        -:   56:{
        -:   57:public :
        -:   58:	/*This multimap will contain the distribution of buckets and its respective values
        -:   59:	 * in sort order. Via this container I will be able to show the result print it to file or STDOUT_FILENO*/
        -:   60:	using info = std::multimap<std::size_t, Key>;
        -:   61:
        -:   62:	explicit Hash_Table(std::size_t size = _HASH_TABLE_SIZE);
        -:   63:	~Hash_Table();
        -:   64:	Hash_Table(const Hash_Table &hash_table);
        -:   65:	Hash_Table(Hash_Table&& rhs) noexcept;
        -:   66:	Hash_Table& operator=(Hash_Table&& rhs) noexcept;
        -:   67:	Hash_Table& operator=(const Hash_Table &ht);
        -:   68:	const std::size_t &size() const noexcept;
        -:   69:	void showDistribution(info &map) const;
        -:   70:	friend std::ofstream &operator<<<>(std::ofstream &out, const Hash_Table<Key> &ht);
        -:   71:private :
        -:   72:
        -:   73:	class Node
        -:   74:	{
        -:   75:		Node *left_ = nullptr;
        -:   76:		Node *right_ = nullptr;
        -:   77:		Key value;
        -:   78:	public:
        -:   79:		explicit Node(const Key &t);
        -:   80:		explicit Node(Key&& t) noexcept;
        -:   81:		Node() = delete;
        -:   82:		const Node *get_right() const noexcept;
        -:   83:		void set_right(Node *right) noexcept;
        -:   84:		void set_left(Node *left) noexcept;
        -:   85:		const Node *get_left() const noexcept;
        -:   86:		Node *get_left() noexcept;
        -:   87:		Node *get_right() noexcept;
        -:   88:		const Key &get_value() const noexcept;
        -:   89:		Node *ptr_to_last_in_bucket(const Node *ptr_from) const noexcept;
        -:   90:	};
        -:   91:
        -:   92:	Node *deep_copy_bucket(const Node *bucket_ptr) const;
        -:   93:	void destroy_bucket(Node *bucket_ptr) const noexcept;
        -:   94:
        -:   95:	class NewHandlerHolder
        -:   96:	{
        -:   97:	public:
    55715:   98:		explicit NewHandlerHolder(std::new_handler ptr)
    55715:   99:			: currentHandler(ptr)
    55715:  100:		{}
        -:  101:		NewHandlerHolder(const NewHandlerHolder &holder) = delete;
        -:  102:		NewHandlerHolder &operator=(const NewHandlerHolder &holder) = delete;
    55715:  103:		~NewHandlerHolder()
    55715:  104:		{ std::set_new_handler(currentHandler); }
        -:  105:	private :
        -:  106:		std::new_handler currentHandler = nullptr;
        -:  107:	};
        -:  108:
        -:  109:
        -:  110:public:
        -:  111:	class Iterator
        -:  112:	{
        -:  113:		using value_type = Key;
        -:  114:		using pointer = Key *;
        -:  115:		using reference = Key &;
        -:  116:		using difference_type = std::size_t;
        -:  117:		using iterator_category = std::bidirectional_iterator_tag;
        -:  118:
        -:  119:	public :
        -:  120:		Iterator() = default;
        -:  121:		Iterator(std::size_t n, std::size_t max, Node *ptr, Node **hash_p);
        -:  122:		Iterator(const Iterator &it) = default;
        -:  123:		Iterator &operator=(const Iterator &it) = default;
        -:  124:
        -:  125:		Key &operator*(); // this operator will cause runtime_error in case when we are about to dereference nullptr
        -:  126:		const Key &operator*() const;
        -:  127:
        -:  128:		Node *operator->();
        -:  129:		const Node *operator->() const;
        -:  130:
        -:  131:		Iterator &operator++() noexcept;
        -:  132:		const Iterator operator++(int);
        -:  133:
        -:  134:		Iterator &operator--() noexcept;
        -:  135:		const Iterator operator--(int);
        -:  136:
        -:  137:		bool operator==(const Iterator &it) const noexcept;
        -:  138:		bool operator!=(const Iterator &it) const noexcept;
        -:  139:
        -:  140:
        -:  141:	private :
        -:  142:		std::size_t nbucket_ = 0; // this variable will maintain the current number of bucket
        -:  143:		std::size_t max_buckets = _HASH_TABLE_SIZE;
        -:  144:		Node *ptr_ =
        -:  145:			nullptr;          // this is the main part of this iterator due to I'm going to go through the left and right pointer
        -:  146:		Node **hash_t = nullptr;     // this pointer will maintain the main array of hash_table
        -:  147:	};
        -:  148:
        -:  149:	Iterator findEl(const Key &key, std::size_t &bucket);
        -:  150:	Iterator begin();
        -:  151:
        -:  152:	Iterator end();
        -:  153:
        -:  154:	template <class U>
        -:  155:	bool insert(U&& key);
        -:  156:	bool erase(const Key &key);
        -:  157:	/*These operators will throw an exception of type std::out_of_range in case when
        -:  158:	 * i is out of bound array hash_t*/
        -:  159:	Node *operator[](const std::size_t i);
        -:  160:	const Node *operator[](const std::size_t i) const;
        -:  161:
        -:  162:private :
        -:  163:
        -:  164:	Node **hash_t = nullptr; // It's a pointer to the array of pointers (aka hash_table structure)
        -:  165:	std::size_t n_buckets = _HASH_TABLE_SIZE;
        -:  166:	static void mem_handler();
        -:  167:	std::size_t hash_func(const Key &key);
        -:  168:
        -:  169:};
        -:  170:
        -:  171:#endif //HASH_TABLE_HASH_TABLE_H
